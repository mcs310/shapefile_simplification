#imports
import geopandas as geop
import numpy
import shapely
from shapely.ops import unary_union
import os
import math

def shapefile_laden():
    while True:
        try:
            path=input("Bitte Pfad zu shapefile eintragen")
            str(path)
            return path
        except:
            print("{path} führt nicht zu einem gültigen shapefile, bitte anderen input wählen")

def rasterung(form,detail,path):
    # form: 6 für sechseck (0, 60, 120, 180, 240, 300) oder 8 für achteck (0, 45, 90, 135, 180, 225, 270, 315)
    # detail: noch nicht genaue idee aber wird zahl die auf noch nciht näher definierte weise das bounding rectangle in ratser teilt
    # fürs Erste min 20, max undefiniert
    #treffen der Annahme, dass die anwendung auf mercator projektionen angewandt wird ,da die vereinfachung gemäß Koordinaten in Polnähe eigenartige Formen ergibt

    shp= geop.read_file(path)
    maxis=shp.total_bounds #extra funktion aus geopands die die maximalerte aus allen polygonen zurückgibt in form [min x, min y, max x, max y]
    raster = []

    if form in (4, 8):
        minx, miny, maxx, maxy = maxis
        width = maxx - minx
        height = maxy - miny
        step = min(width, height) / (20 + detail)
        y = miny
        while y <= maxy:
            x = minx
            while x <= maxx:
                raster.append([x, y])
                x += step
            y += step

    elif form==6:                   #sechseck form
        minx, miny, maxx, maxy = maxis
        width = maxx - minx
        height = maxy - miny        #bleibt erstmal drin, auch wenn nicht länger benötigt

        spacing = width / (20 + detail)

        # Höhe zwischen den Zeilen
        step_y = numpy.sqrt(3) * spacing / 2  # ~0.866 * s

        y = miny
        row = 0
        while y <= maxy:
            # Versatz für jede zweite Zeile
            x_start = minx + (1.5 * spacing if row % 2 == 1 else 0)

            x = x_start
            pair = 0  # Zählt, ob wir in der 2er-Gruppe sind
            while x <= maxx:
                if pair < 2:
                    raster.append([x, y])
                # 2 Punkte, 1 Lücke → alle 3 Rasterstellen
                pair = (pair + 1) % 3
                x += spacing
            y += step_y
            row += 1

    else:
        raise ValueError("Form muss 4, 6 oder 8 sein.")     #muss kein value error sein aber dann stoppt programm immerhin mit sinnvoller message

    return raster

def next_p(x,y,raster):
    abstand=[]
    for rx, ry in raster:
        abstand.append((x - rx) ** 2 + (y - ry) ** 2)                 #wurzel fällt weg da numerischer abstand nicht relevant, nur welcher am größten ist
    ras_index=abstand.index(min(abstand))                             #gibt mir den index des maximalen abstand und da index zwischen den beiden listen korrespondiert auch index für das nächste koordinatenpaar
    return raster[ras_index]

def snap(obj,raster):
    außen = [next_p(x, y, raster) for x, y in obj.exterior.coords]    #annahme wir haben donuts (brandenburg), (fürs erste nur EINE Landesfläche (sry Exklaven)) gefixt

    innen = []
    for fl in obj.interiors:                                            #annahme mehrere löcher möglich (siehe Italien)
        innen_kr = [next_p(x,y,raster) for x,y in fl.coords]
        innen.append(innen_kr)
    return  shapely.geometry.Polygon(außen,innen)

def snap_geometry(geom, raster_pts): #Unterteilung je nach Art
    if geom.is_empty:   #notwendig da sonst bei einem polygon in world shapefile stockt
        return geom
    if geom.geom_type == "Polygon":      #standard für die meisten polygone
        return snap(geom, raster_pts)
    if geom.geom_type == "MultiPolygon":    #Exklaven usw
        return shapely.geometry.MultiPolygon([snap(p, raster_pts) for p in geom.geoms])
    return geom

def vereinfachen(pfad, raster, detail, form):           #ruft nacheinander alle funktionen auf
    shp = geop.read_file(pfad)
    minx, miny, maxx, maxy = shp.total_bounds
    width = maxx - minx
    spacing = width / (20 + detail)

    shp = preprocess_small_polygons(shp, spacing, min_area_factor=0.5, buffer_factor=0.2)       #erst zu kleine dinge entfernen

    snapped = [snap_geometry(g, raster) for g in shp["geometry"]]                               #einfaches closest point snappen
    cleaned = [postprocess_snapped_geometry(g, raster, spacing, form, tol=spacing * 1e-3) for g in snapped]

    shp["geometry"] = cleaned
    return shp


def dist(a, b):
    return math.hypot(a[0]-b[0], a[1]-b[1])

def is_close(a, b, tol):
    return abs(a - b) <= tol

def allowed_base_dirs(spacing, form):
    s = spacing
    if form == 4:  # Quadrat
        return [(s, 0.0), (0.0, s)]
    if form == 6:  # Hex
        h = (math.sqrt(3)/2.0) * s
        return [(s, 0.0), (0.5*s, h), (-0.5*s, h)]
    if form == 8:  # Quadrat + Diagonalen
        return [(s, 0.0), (0.0, s), (s, s), (s, -s)]
    raise ValueError("Form muss 4, 6 oder 8 sein.")

def snap_along_allowed_lines(p, q, spacing, tol, form):
    dirs = allowed_base_dirs(spacing, form)
    vx = q[0] - p[0]
    vy = q[1] - p[1]
    best = None
    best_d = float("inf")
    for dx, dy in dirs:
        for sx, sy in ((dx, dy), (-dx, -dy)):
            denom = sx*sx + sy*sy               #einfache distanz
            if denom == 0:
                continue
            t = (vx*sx + vy*sy) / denom         #erweiterte distanz
            n = round(t)
            nx = p[0] + n*sx
            ny = p[1] + n*sy
            d = dist((nx, ny), q)
            if d < best_d:
                best_d = d
                best = (nx, ny)
    if best_d <= tol:
        return best
    if best_d <= 2*tol:
        return best
    return None


def is_valid_step(p, q, spacing, form, tol=1e-6):
    dx = q[0] - p[0]
    dy = q[1] - p[1]
    dirs = allowed_base_dirs(spacing, form)
    for vx, vy in dirs + [(-vx, -vy) for vx, vy in dirs]:
        if math.isclose(dx, vx, abs_tol=tol) and math.isclose(dy, vy, abs_tol=tol):
            return True
    return False

def step_towards_goal(current, goal, raster, spacing, form, tol=1e-6):
    # nur Nachbarn aus dem Raster, die gültige Schritte sind
    candidates = []
    for pt in raster:
        if is_valid_step(current, pt, spacing, form, tol):
            candidates.append(pt)
    if not candidates:
        return None
    # Kandidaten prüfen: welcher nähert sich dem Ziel am meisten an?
    best = min(candidates, key=lambda pt: dist(pt, goal))
    if dist(best, goal) < dist(current, goal) - tol:
        return best
    return None

def connect_along_grid(start, goal, raster, spacing, form, tol=1e-6, max_iter=10000):
    path = [start]
    current = start
    for _ in range(max_iter):
        if dist(current, goal) <= tol:
            path.append(goal)
            break
        if is_valid_step(current, goal, spacing, form, tol):
            path.append(goal)
            break
        step = step_towards_goal(current, goal, raster, spacing, form, tol)
        if step is None:
            # kein Fortschritt möglich → Ziel direkt verbinden
            path.append(goal)
            break
        path.append(step)
        current = step
    return path

def clean_ring_coords(coords, raster, spacing, tol, form):
    if len(coords) < 4:
        return coords
    open_coords = list(coords[:-1])  # letztes Duplikat entfernen
    result = []
    seen_index = {}

    def push(pt):
        if not result or (result[-1][0] != pt[0] or result[-1][1] != pt[1]):
            result.append(pt)

    for pt in open_coords:
        key = (round(pt[0], 12), round(pt[1], 12))
        if key in seen_index:
            cut_idx = seen_index[key]
            result = result[:cut_idx+1]
            seen_index.clear()
            for i, p in enumerate(result):
                seen_index[(round(p[0],12), round(p[1],12))] = i
        else:
            push(pt)
            seen_index[key] = len(result)-1

    if len(result) >= 2:
        fixed = [result[0]]
        for i in range(1, len(result)):
            p = fixed[-1]
            q = result[i]
            segment = connect_along_grid(p, q, raster, spacing, form, tol)
            if len(segment) > 1:
                fixed.extend(segment[1:])
        result = fixed

    # Ring explizit schließen
    if len(result) >= 3:
        if not (math.isclose(result[0][0], result[-1][0], abs_tol=tol) and
                math.isclose(result[0][1], result[-1][1], abs_tol=tol)):
            close_seg = connect_along_grid(result[-1], result[0], raster, spacing, form, tol)
            if len(close_seg) > 1:
                result.extend(close_seg[1:])
        if result[0] != result[-1]:
            result.append(result[0])
    else:
        return coords

    # Doppelpunkte entfernen
    cleaned = [result[0]]
    for p in result[1:]:
        if p != cleaned[-1]:
            cleaned.append(p)

    if len(cleaned) < 4:
        return coords
    return cleaned

def clean_polygon(poly, raster, spacing, tol, form):
    # Außenring bereinigen
    ext = clean_ring_coords(list(poly.exterior.coords), raster, spacing, tol, form)

    # Innenringe (Löcher) bereinigen
    ints = []
    for r in poly.interiors:
        cr = clean_ring_coords(list(r.coords), raster, spacing, tol, form)
        if len(cr) >= 4:  # nur gültige Ringe behalten
            ints.append(cr)

    try:
        new_poly = shapely.geometry.Polygon(ext, ints)
        if not new_poly.is_valid:
            new_poly = new_poly.buffer(0)  # automatische Reparatur
        return new_poly
    except:
        return poly  # Fallback, falls Reparatur fehlschlägt


def preprocess_small_polygons(shp, spacing, min_area_factor=0.5, buffer_factor=0.2):
    min_area = (spacing**2) * min_area_factor
    radius = max(spacing * buffer_factor, 1e-9)

    processed = []
    for g in shp["geometry"]:
        if g.is_empty:
            processed.append(g)
            continue

        if isinstance(g, shapely.geometry.Polygon):
            if g.area < min_area:
                processed.append(g.centroid.buffer(radius, resolution=8))
            else:
                processed.append(g)

        elif isinstance(g, shapely.geometry.MultiPolygon):
            parts = []
            for p in g.geoms:
                if p.area < min_area:
                    parts.append(p.centroid.buffer(radius, resolution=8))
                else:
                    parts.append(p)
            processed.append(shapely.ops.unary_union(parts))  # ergibt Polygon/MultiPolygon

        else:
            processed.append(g)

    shp = shp.copy()
    shp["geometry"] = processed
    return shp


def postprocess_snapped_geometry(geom, raster, spacing, form, tol=1e-6):
    if geom.is_empty:
        return geom
    if isinstance(geom, shapely.geometry.Polygon):
        return clean_polygon(geom, raster, spacing, tol, form)
    if isinstance(geom, shapely.geometry.MultiPolygon):
        parts = [clean_polygon(p, raster, spacing, tol, form) for p in geom.geoms]
        return shapely.ops.unary_union(parts)
    return geom


if __name__ == "__main__":
    pfad= shapefile_laden()
    form=int(input("Bitte Form angeben. [4/6/8]"))
    detail=int(input("Bitte Detailgrad angeben. [0-100]"))
    neues_shp = vereinfachen(pfad,                                          #reihenfolge suckt aber zu unsauber um es zu korrigieren, funktioniert auch so
                             rasterung(form,detail,pfad),
                             detail,
                             form
                             )

    '''folgernder Teil entstammt frei nach Tutorial von Corey Schafer nach https://www.youtube.com/watch?v=tJxcKyFMTGo '''
    original_dir = os.path.dirname(pfad)
    new_folder_name = "snapped"
    new_folder_path = os.path.join(original_dir, new_folder_name)
    os.makedirs(new_folder_path, exist_ok=True)
    output_shapefile_path = os.path.join(new_folder_path, "snapped.shp")
    '''Ende des Teils gemäß Corey Schafer'''

    neues_shp.to_file(output_shapefile_path )





